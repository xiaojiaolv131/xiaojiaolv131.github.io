<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Hulk Lv"><title>webpack学习 · Hulk Lv' Blog</title><meta name="description" content="为什么要使用webpack？现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法：

模块化，让我们可以把复杂的程序细化为小的文件;
类似于TypeScript这种在JavaScript基础上拓展的"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hulk Lv' Blog</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a href="https://github.com/xiaojiaolv131">GitHub </a><a href="http://weibo.com/u/1172318487"> WeiBo </a></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>webpack学习</a></h3></div><div class="post-content"><h2 id="为什么要使用webpack？"><a href="#为什么要使用webpack？" class="headerlink" title="为什么要使用webpack？"></a>为什么要使用webpack？</h2><p>现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法：</p>
<ul>
<li>模块化，让我们可以把复杂的程序细化为小的文件;</li>
<li>类似于TypeScript这种在JavaScript基础上拓展的开发语言：使我们能够实现目前版本的JavaScript不能直接使用的特性，并且之后还能能装换为JavaScript文件使浏览器可以识别；</li>
<li>Scss，less等CSS预处理器</li>
<li>…</li>
</ul>
<p>这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常反锁的，这就为webpack类的工具的出现提供了需求。</p>
<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><p>webpack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。</p>
<h2 id="webpack和Grunt以及Gulp相比有什么特性"><a href="#webpack和Grunt以及Gulp相比有什么特性" class="headerlink" title="webpack和Grunt以及Gulp相比有什么特性"></a>webpack和Grunt以及Gulp相比有什么特性</h2><p>其实，webpack和另外两个并没有太多的可比性，Gulp/Grunt是一种能够<code>优化前端的开发流程</code>的工具，而webpack是一种<code>模块化</code>的解决方案，不过webpack的优点使得webpack可以替代Gulp/Grunt类的工具。</p>
<p>Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。<br><img src="https://sfault-image.b0.upaiyun.com/280/295/2802953772-58e869653e270_articlex" alt="Alt text"><br></p>
<p>webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。<br><img src="https://sfault-image.b0.upaiyun.com/227/478/2274783009-58e86965b7131_articlex" alt="Alt text"><br></p>
<p>如果实在要把二者进行比较，webpack的处理速度更快更直接，能打包更多不同类型的文件。</p>
<h2 id="开始使用webpack"><a href="#开始使用webpack" class="headerlink" title="开始使用webpack"></a>开始使用webpack</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用npm安装，新建一个空的练习文件夹（此处命名为webpack sample progect），在终端中转到该文件夹后执行下述指令就可以完成安装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//全局安装</div><div class="line">$ npm install -g webpack</div><div class="line">//安装到你的项目目录</div><div class="line">$ npm install --save-dev webpack</div></pre></td></tr></table></figure>
<h3 id="正式使用webpack前的准备"><a href="#正式使用webpack前的准备" class="headerlink" title="正式使用webpack前的准备"></a>正式使用webpack前的准备</h3><p>在上述练习文件夹中创建一个package.json文件，这是一个标准的npm说明文件，里面蕴含了丰富的信息，包括当前项目的依赖模块，自定义的脚本任务等等。在终端中使用npm init命令可以自动创建这个package.json文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm init</div></pre></td></tr></table></figure>
<p>输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过不用担心，如果你不准备在npm中发布你的模块，这些问题的答案都不重要，回车默认即可。</p>
<p>package.json文件已经就绪，我们在本项目中安装Webpack作为依赖包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//安装到你的项目目录</div><div class="line">$ npm install --save-dev webpack</div></pre></td></tr></table></figure></p>
<p>下面来说一说webpack.config.js中对webpack的主要配置：</p>
<h4 id="entry（入口）"><a href="#entry（入口）" class="headerlink" title="entry（入口）"></a>entry（入口）</h4><p>用来指明webpack构建的唯一入口文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">entry: __dirname + <span class="string">'/src/main'</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>注：“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
</blockquote>
<h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    path: path.join(__dirname,&apos;./dist&apos;),//打包后的文件存放的地方</div><div class="line">    filename: &apos;[name]-[hash].js&apos;//打包后输出文件的文件名</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在如果你需要打包文件只需要在终端里你运行<code>webpack</code>(非全局安装需使用<code>node_modules/.bin/webpack</code>)命令就可以了，这条命令会自动参考<code>webpack.config.js</code>文件中的配置选项打包你的项目，输出结果如下:<br><img src="/imgs/C9DACE0B-8D80-4A07-8DF8-1349AC929CCF.png" alt="Alt text"><br></p>
<p>又学会了一种使用Webpack的方法，而且不用管那烦人的命令行参数了，有没有感觉很爽。有没有想过如果可以连webpack(非全局安装需使用node_modules/.bin/webpack)这条命令都可以不用，那种感觉会不会更爽~，继续看下文。</p>
<h3 id="Webpack的强大功能"><a href="#Webpack的强大功能" class="headerlink" title="Webpack的强大功能"></a>Webpack的强大功能</h3><h4 id="devtool-生成Source-Maps（使调试更容易）"><a href="#devtool-生成Source-Maps（使调试更容易）" class="headerlink" title="devtool(生成Source Maps（使调试更容易）)"></a>devtool(生成Source Maps（使调试更容易）)</h4><h4 id="devServer-使用webpack构建本地服务器"><a href="#devServer-使用webpack构建本地服务器" class="headerlink" title="devServer(使用webpack构建本地服务器)"></a>devServer(使用webpack构建本地服务器)</h4><p>想不想让你的浏览器监测你都代码的修改，并自动刷新修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//安装到你的项目目录</div><div class="line">$ npm install --save-dev webpack-dev-server</div></pre></td></tr></table></figure>
<p>devserver作为webpack配置选项中的一项：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">devServer: &#123;</div><div class="line">    <span class="attr">contentBase</span>: <span class="string">"./public"</span>,<span class="comment">//本地服务器所加载的页面所在的目录(默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录（本例设置到“public"目录）)</span></div><div class="line">    colors: <span class="literal">true</span>,<span class="comment">//终端中输出结果为彩色</span></div><div class="line">    historyApiFallback: <span class="literal">true</span>,<span class="comment">//不跳转</span></div><div class="line">    inline: <span class="literal">true</span><span class="comment">//实时刷新</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Loaders（在打包构建过程中用来处理源文件的（JSX，Scss，Less-），一次处理一个）"><a href="#Loaders（在打包构建过程中用来处理源文件的（JSX，Scss，Less-），一次处理一个）" class="headerlink" title="Loaders（在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个）"></a>Loaders（在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个）</h4><p>Loaders是webpack中最让人激动人心的功能之一了。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。</p>
<p>Loaders需要单独安装并且需要在webpack.config.js下的<code>module</code>关键字下进行配置，Loaders的配置选项包括以下几方面：</p>
<ul>
<li>test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须）</li>
<li>loader：loader的名称（必须）</li>
<li>include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；</li>
<li>query：为loaders提供额外的设置选项（可选）</li>
</ul>
<blockquote>
<p>Babel<br>Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的：</p>
<ul>
<li>下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持；</li>
<li>使用基于JavaScript进行了拓展的语言，比如React的JSX</li>
</ul>
<p>Babel的安装与配置<br>Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包）。<br>我们先来一次性安装这些依赖包:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//安装到你的项目目录</div><div class="line">// npm一次性安装多个依赖模块，模块之间用空格隔开</div><div class="line">$ npm install --save-dev babel-core babel-loader babel-preset-es2015</div></pre></td></tr></table></figure></p>
<p>在webpack中配置Babel的方法如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;<span class="comment">// 添加 module 模块，把 loaders 配置在此模块中</span></div><div class="line">    loaders: [</div><div class="line">    <span class="comment">// 解析.vue文件</span></div><div class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, <span class="attr">loader</span>: <span class="string">'vue'</span> &#125;,</div><div class="line">    <span class="comment">// 转化ES6的语法,除了/node_modules/目录下的</span></div><div class="line">        &#123; </div><div class="line">            <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, </div><div class="line">            <span class="attr">loader</span>: <span class="string">'babel'</span>, </div><div class="line">            <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,<span class="comment">//排除该目录</span></div><div class="line">            query: &#123; <span class="comment">// loader 的其他选项，babel 的配置项</span></div><div class="line">                presets: [<span class="string">'es2015'</span>]</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">    <span class="comment">// 编译css并自动添加css前缀</span></div><div class="line">    <span class="comment">// &#123; test: /\.css$/, loader: 'style-loader!css-loader!autoprefixer'&#125;,</span></div><div class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: ExtractTextPlugin.extract(<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>)&#125;,<span class="comment">//'style-loader!css-loader!autoprefixer'</span></div><div class="line">    <span class="comment">// 图片转化，小于8K自动转化为base64的编码</span></div><div class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125;,</div><div class="line">    <span class="comment">// html模板编译？</span></div><div class="line">        &#123; <span class="attr">test</span>: <span class="regexp">/\.(html|tpl)$/</span>, <span class="attr">loader</span>: <span class="string">'html-loader'</span> &#125;,</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;</div><div class="line">    <span class="attr">loaders</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</div><div class="line">        <span class="attr">loader</span>: <span class="string">'babel'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p><code>.babelrc</code>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//.babelrc</span></div><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span>: [<span class="string">"es2015"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>到目前为止，我们已经知道了，对于模块，Webpack能提供非常强大的处理功能，那哪些是模块呢？<br>一切皆模块！！！！Webpack有一个不可不说的优点，它把所有的文件都可以当做模块处理，包括你的JavaScript代码，也包括CSS和fonts以及图片等等等，只有通过合适的loaders，它们都可以被当做模块被处理。</p>
<blockquote>
<p>CSS<br>webpack提供两个工具处理样式表，css-loader 和 style-loader，二者处理的任务不同，css-loader使你能够使用类似@import 和 url(…)的方法实现 require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//安装到你的项目目录</div><div class="line">$ npm install --save-dev style-loader css-loader</div></pre></td></tr></table></figure></p>
<p>配置如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>: &#123;<span class="comment">// 添加 module 模块，把 loaders 配置在此模块中</span></div><div class="line">        loaders: [</div><div class="line">        <span class="comment">// 解析.vue文件</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, <span class="attr">loader</span>: <span class="string">'vue'</span> &#125;,</div><div class="line">        <span class="comment">// 转化ES6的语法,除了/node_modules/目录下的</span></div><div class="line">            &#123; </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>, </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,<span class="comment">//排除该目录</span></div><div class="line">                query: &#123; <span class="comment">// loader 的其他选项，babel 的配置项</span></div><div class="line">                    presets: [<span class="string">'es2015'</span>]</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">        <span class="comment">// 编译css并自动添加css前缀</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: <span class="string">'style-loader!css-loader!autoprefixer'</span>&#125;,</div><div class="line">        <span class="comment">// 图片转化，小于8K自动转化为base64的编码</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125;,</div><div class="line">        <span class="comment">// html模板编译？</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(html|tpl)$/</span>, <span class="attr">loader</span>: <span class="string">'html-loader'</span> &#125;,</div><div class="line">        ]</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>注：感叹号的作用在于使同一文件能够使用不同类型的loader</p>
<p>接下来，在src-&gt;static-&gt;css文件夹里创建一个名字为”common.css”等的文件，对一些元素设置样式。你还记得吗？webpack只有单一的入口，其它的模块需要通过 import, require, url等导入相关位置，为了让webpack能找到”common.css“等文件，我们把它导入”main.js “中，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'./static/css/common.css'</span></div><div class="line"><span class="keyword">import</span> <span class="string">'./static/css/vux.css'</span></div><div class="line"><span class="keyword">import</span> <span class="string">'./static/css/swiper.min.css'</span></div><div class="line"><span class="keyword">import</span> <span class="string">'./static/css/my-job.css'</span></div><div class="line"><span class="keyword">import</span> <span class="string">'./static/css/joblist.css'</span></div></pre></td></tr></table></figure></p>
<p>通常情况下，css会和js打包到同一个文件中，并不会打包为一个单独的css文件，不过通过合适的配置webpack也可以把css打包为单独的文件的。</p>
<p>postcss(css预处理器)<br>Sass 和 Less之类的预处理器是对原生CSS的拓展，它们允许你使用类似于variables, nesting, mixins, inheritance等不存在于CSS中的特性来写CSS，CSS预处理器可以这些特殊类型的语句转化为浏览器可识别的CSS语句，你现在可能都已经熟悉了，在webpack里使用相关loaders进行配置就可以使用了，以下是常用的CSS 处理loaders</p>
<ul>
<li>Less Loader</li>
<li>Sass Loader</li>
<li>Stylus Loader</li>
</ul>
<p>不过其实也存在一个CSS的处理平台-PostCSS，它可以帮助你的CSS实现更多的功能，在其CSS官方文档可了解更多相关知识。<br>举例来说如何使用PostCSS，我们使用PostCSS来为CSS代码自动添加适应不同浏览器的CSS前缀。<br>首先安装postcss-loader 和 autoprefixer（自动添加前缀的插件）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//安装到你的项目目录</div><div class="line">$ npm install --save-dev postcss-loader autoprefixer</div></pre></td></tr></table></figure></p>
<p>接下来，在webpack配置文件中进行设置，只需要新建一个postcss关键字，并在里面申明依赖的插件，如下，现在你写的css会自动根据Can i use里的数据添加不同前缀了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">postcss: [</div><div class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)<span class="comment">//调用autoprefixer插件</span></div><div class="line">]</div></pre></td></tr></table></figure></p>
</blockquote>
<p>到现在，本文已经涉及到处理JS的Babel和处理CSS的PostCSS，它们其实也是两个单独的平台，配合Webpack可以很好的发挥它们的作用（ExtractTextPlugin分离CSS和JS文件）。接下来介绍Webpack中另一个非常重要的功能-Plugins</p>
<h4 id="plugins（插件，插件并不直接操作单个文件，它直接对整个构建过程起作用）"><a href="#plugins（插件，插件并不直接操作单个文件，它直接对整个构建过程起作用）" class="headerlink" title="plugins（插件，插件并不直接操作单个文件，它直接对整个构建过程起作用）"></a>plugins（插件，插件并不直接操作单个文件，它直接对整个构建过程起作用）</h4><p>插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。<br>Webpack有很多内置插件，同时也有很多第三方插件，可以让我们完成更加丰富的功能。</p>
<h5 id="使用插件的方法"><a href="#使用插件的方法" class="headerlink" title="使用插件的方法"></a>使用插件的方法</h5><p>要使用某个插件，我们需要通过npm安装它，然后要做的就是在webpack配置中的plugins关键字部分添加该插件的一个实例（plugins是一个数组）继续看例子，我们添加了一个实现版权声明的插件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//webpack.config.js</span></div><div class="line"><span class="meta">"use strict"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</div><div class="line"><span class="keyword">let</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</div><div class="line"><span class="keyword">let</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>)</div><div class="line"><span class="keyword">let</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</div><div class="line"><span class="keyword">let</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">entry</span>: <span class="string">'./src/main'</span>,</div><div class="line">    <span class="attr">output</span>: &#123;</div><div class="line">        <span class="attr">path</span>: path.join(__dirname,<span class="string">'./dist'</span>),</div><div class="line">        <span class="attr">filename</span>: <span class="string">'[name].js'</span>,</div><div class="line">        <span class="attr">publicPath</span>: <span class="string">'/'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// devServer: &#123;</span></div><div class="line">    <span class="comment">//  historyApiFallback: true,</span></div><div class="line"> <span class="comment">//        hot: false,</span></div><div class="line"> <span class="comment">//        inline: true,</span></div><div class="line"> <span class="comment">//        grogress: true,</span></div><div class="line"> <span class="comment">//        colors: true</span></div><div class="line">    <span class="comment">// &#125;,</span></div><div class="line">    <span class="built_in">module</span>: &#123;<span class="comment">// 添加 module 模块，把 loaders 配置在此模块中</span></div><div class="line">        loaders: [</div><div class="line">        <span class="comment">// 解析.vue文件</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, <span class="attr">loader</span>: <span class="string">'vue'</span> &#125;,</div><div class="line">        <span class="comment">// 转化ES6的语法,除了/node_modules/目录下的</span></div><div class="line">            &#123; </div><div class="line">                <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, </div><div class="line">                <span class="attr">loader</span>: <span class="string">'babel'</span>, </div><div class="line">                <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,<span class="comment">//排除该目录</span></div><div class="line">                query: &#123; <span class="comment">// loader 的其他选项，babel 的配置项</span></div><div class="line">                    presets: [<span class="string">'es2015'</span>]</div><div class="line">                &#125;</div><div class="line">            &#125;,</div><div class="line">        <span class="comment">// 编译css并自动添加css前缀</span></div><div class="line">        <span class="comment">// &#123; test: /\.css$/, loader: 'style-loader!css-loader!autoprefixer'&#125;,</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">loader</span>: ExtractTextPlugin.extract(<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>)&#125;,<span class="comment">//'style-loader!css-loader!autoprefixer'</span></div><div class="line">        <span class="comment">// 图片转化，小于8K自动转化为base64的编码</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(png|jpg|gif)$/</span>, <span class="attr">loader</span>: <span class="string">'url-loader?limit=8192'</span>&#125;,</div><div class="line">        <span class="comment">// html模板编译？</span></div><div class="line">            &#123; <span class="attr">test</span>: <span class="regexp">/\.(html|tpl)$/</span>, <span class="attr">loader</span>: <span class="string">'html-loader'</span> &#125;,</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugins</span>: [</div><div class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"Copyright Flying Unicorns inc."</span>),<span class="comment">//在这个数组中new一个就可以了</span></div><div class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].[contenthash].css"</span>,&#123;</div><div class="line">          <span class="attr">allChunks</span>: <span class="literal">true</span>,</div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</div><div class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</div><div class="line">            <span class="attr">title</span>: <span class="string">'My App'</span>,</div><div class="line">            <span class="attr">filename</span>: <span class="string">'index.html'</span>,</div><div class="line">            <span class="attr">template</span>: <span class="string">'index.html'</span></div><div class="line">        &#125;)</div><div class="line">    ],</div><div class="line">    <span class="comment">// postcss: [autoprefixer()],</span></div><div class="line">     <span class="comment">// vue: &#123;</span></div><div class="line">  <span class="comment">//       loaders: &#123;</span></div><div class="line">  <span class="comment">//           css: 'style!css!autoprefixer',</span></div><div class="line">  <span class="comment">//       &#125;</span></div><div class="line">  <span class="comment">//   &#125;,</span></div><div class="line">    <span class="comment">// 转化成es5的语法</span></div><div class="line">    babel: &#123;</div><div class="line">        <span class="attr">presets</span>: [<span class="string">'es2015'</span>],</div><div class="line">        <span class="attr">plugins</span>: [<span class="string">'transform-runtime'</span>]</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">resolve</span>: &#123;</div><div class="line">        <span class="comment">// require时省略的扩展名，如：require('module') 不需要module.js</span></div><div class="line">        extensions: [<span class="string">''</span>, <span class="string">'.js'</span>, <span class="string">'.vue'</span>],</div><div class="line">        <span class="comment">// 别名，可以直接使用别名来代表设定的路径以及其他</span></div><div class="line">        alias: &#123;</div><div class="line">            <span class="attr">filter</span>: path.join(__dirname, <span class="string">'./src/filters'</span>),</div><div class="line">            <span class="attr">components</span>: path.join(__dirname, <span class="string">'./src/components'</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;<span class="comment">//,</span></div><div class="line">    <span class="comment">// 开启source-map，webpack有多种source-map，在官网文档可以查到</span></div><div class="line">    <span class="comment">// devtool: 'eval-source-map'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过这个插件，打包后的JS文件显示如下：<br><img src="/imgs/D681F49F-593C-4B1C-862A-992682862381.png" alt="Alt text"><br></p>
<p>知道Webpack中的插件如何使用了，下面给大家推荐几个常用的插件</p>
<h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><h4 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h4><h4 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h4><h3 id="产品阶段的构建"><a href="#产品阶段的构建" class="headerlink" title="产品阶段的构建"></a>产品阶段的构建</h3><p>目前为止，我们已经使用webpack构建了一个完整的开发环境。但是在产品阶段，可能还需要对打包的文件进行额外的处理，比如说优化，压缩，缓存以及分离CSS和JS。</p>
<p>对于复杂的项目来说，需要复杂的配置，这时候分解配置文件为多个小的文件可以使得事情井井有条，以上面的例子来说，我们创建一个“webpack.production.config.js”的文件，在里面加上基本的配置,它和原始的webpack.config.js很像，如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="string">``</span><span class="string">`</span></div><div class="line"></div><div class="line">package.json:</div><div class="line">`<span class="string">``</span>javascript</div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"webpack-sample-project"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</div><div class="line">  <span class="string">"description"</span>: <span class="string">"Sample webpack project"</span>,</div><div class="line">  <span class="string">"scripts"</span>: &#123;</div><div class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server --progress"</span>,</div><div class="line">    <span class="string">"build"</span>: <span class="string">"NODE_ENV=production webpack --config ./webpack.production.config.js --progress"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"Cássio Zen"</span>,</div><div class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;...&#125;,</div><div class="line">  <span class="string">"dependencies"</span>: &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="优化插件"><a href="#优化插件" class="headerlink" title="优化插件"></a>优化插件</h4><p>webpack提供了一些在发布阶段非常有用的优化插件，它们大多来自于webpack社区，可以通过npm安装，通过以下插件可以完成产品发布阶段所需的功能</p>
<ul>
<li>OccurenceOrderPlugin :为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID</li>
<li>UglifyJsPlugin：压缩JS代码；</li>
<li>ExtractTextPlugin：分离CSS和JS文件</li>
</ul>
<p>我们继续用例子来看看如何添加它们，OccurenceOrder 和 UglifyJS plugins 都是内置插件，你需要做的只是安装它们:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev extract-text-webpack-plugin</div></pre></td></tr></table></figure></p>
<p>在配置文件的plugins后引用它们<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">plugins: [</div><div class="line">        <span class="keyword">new</span> webpack.BannerPlugin(<span class="string">"Copyright Hulk Lv."</span>),<span class="comment">//在这个数组中new一个就可以了</span></div><div class="line">        <span class="keyword">new</span> ExtractTextPlugin(<span class="string">"[name].[contenthash].css"</span>,&#123;<span class="comment">//分离css和js</span></div><div class="line">          allChunks: <span class="literal">true</span>,</div><div class="line">        &#125;),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.OccurenceOrderPlugin(),</div><div class="line">        <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</div><div class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</div><div class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="comment">//这个插件可以帮助生成 HTML 文件，在 body 元素中，使用 script 来包含所有你的 webpack bundles，只需要在你的 webpack 配置文件中如下配置：</span></div><div class="line">            title: <span class="string">'My App'</span>,<span class="comment">//用来生成页面的 title 元素</span></div><div class="line">            filename: <span class="string">'index.html'</span>,<span class="comment">//输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录</span></div><div class="line">            template: <span class="string">'index.html'</span><span class="comment">//模板文件路径</span></div><div class="line">        &#125;)</div><div class="line">    ]</div></pre></td></tr></table></figure></p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存无处不在，使用缓存的最好方法是保证你的文件名和文件内容是匹配的（内容改变，名称相应改变）</p>
<p>webpack可以把一个哈希值添加到打包的文件名中，使用方法如下,添加特殊的字符串混合体（[name], [id] and [hash]）到输出文件名前:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    <span class="attr">path</span>: __dirname + <span class="string">"/build"</span>,</div><div class="line">    <span class="attr">filename</span>: <span class="string">"[name]-[hash].js"</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>构建之后的目录：<br><img src="/imgs/E671E80C-75AB-4CEC-86DE-3CED5750E44A.png" alt="Alt text"><br></p>
<p>现在用户会有合理的缓存了。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-22</span><i class="fa fa-tag"></i><a href="/tags/webpack/" title="webpack" class="tag">webpack </a><a href="/tags/gulp/" title="gulp" class="tag">gulp </a><a href="/tags/grunt/" title="grunt" class="tag">grunt </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/2017/06/22/webpack学习/,Hulk Lv' Blog,webpack学习,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/06/25/HTTP-Cookie/" title="HTTP-Cookie" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/06/20/算法相关/" title="算法相关" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>